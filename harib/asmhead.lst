GAS LISTING asmhead.s 			page 1


   1              	    .code16
   2              	
   3              	    .set BOTPAK, 0x00280000 # bootpack load destination
   4              	    .set DSKCAC, 0x00100000 # disk cache
   5              	    .set DSKCAC0, 0x00008000 # disc cache (real mode)
   6              	
   7              	    # BOOT_INFO
   8              	    .set CYLS, 0x0ff0
   9              	    .set LEDS, 0x0ff1
  10              	    .set VMODE, 0x0ff2 # bit color
  11              	    .set SCRNX, 0x0ff4 # resolution X
  12              	    .set SCRNY, 0x0ff6 # resolution Y
  13              	    .set VRAM, 0x0ff8 # start of graphic buffer
  14              	
  15 0000 B400     	    mov $0x00, %ah # AT BIOS: ビデオモード設定
  16 0002 B013     	    mov $0x13, %al # mode: VGA 320x200 8bit color packed pixel (?)
  17 0004 CD10     	    int $0x10
  18              	
  19              	    # set video configs to BOOT_INFO
  20 0006 C606F20F 	    movb $8, VMODE
  20      08
  21 000b C706F40F 	    movw $320, SCRNX
  21      4001
  22 0011 C706F60F 	    movw $200, SCRNY
  22      C800
  23 0017 66C706F8 	    movl $0x000a0000, VRAM
  23      0F00000A 
  23      00
  24              	
  25              	    # get keyboard state from BIOS
  26 0020 B402     	    mov $0x02, %ah
  27 0022 CD16     	    int $0x16
  28 0024 A2F10F   	    mov %al, LEDS
  29              	
  30              	# ここからの解説は後回しらしい また来る
  31              	    # prevent PIC from interrupt
  32              	    # in PC/AT specification, do this before CLI
  33              	    # or get hanged up
  34              	    # we do PIC initialize later
  35 0027 B0FF     	    mov $0xff, %al
  36 0029 E621     	    out %al, $0x21 # out: write %AL to serial port
  37 002b 90       	    nop
  38 002c E6A1     	    out %al, $0xa1
  39              	
  40              	    # set A20GATE to make memory over 1MB accessible from CPU
  41 002e E8AE00   	    call waitkbdout
  42 0031 B0D1     	    mov $0xd1, %al
  43 0033 E664     	    out %al, $0x64
  44 0035 E8A700   	    call waitkbdout
  45 0038 B0DF     	    mov $0xdf, %al # enable A20
  46 003a E660     	    out %al, $0x60
  47 003c E8A000   	    call waitkbdout
  48              	
  49              	# enable protect mode
  50              	    # .arch i486 とかにすれば変な命令に対して警告してくれるようにもなる
  51              	    .code32 # instrset i486p
  52 003f 0F011500 	    lgdt (GDTR0) # LGDT GDTR m: load global descriptor table register
GAS LISTING asmhead.s 			page 2


  52      000000
  53 0046 0F20C0   	    mov %cr0, %eax # cr0: control register 0
  54 0049 25FFFFFF 	    and $0x7fffffff, %eax # set bit31 to 0
  54      7F
  55 004e 83C801   	    or $0x00000001, %eax # set bit0 to 1
  56 0051 0F22C0   	    mov %eax, %cr0
  57 0054 EB00     	    jmp pipelineflush
  58              	
  59              	pipelineflush:
  60 0056 66B80800 	    mov $1*8, %ax # これ大丈夫？
  61 005a 8ED8     	    mov %ax, %ds
  62 005c 8EC0     	    mov %ax, %es
  63 005e 8EE0     	    mov %ax, %fs
  64 0060 8EE8     	    mov %ax, %gs
  65 0062 8ED0     	    mov %ax, %ss
  66              	
  67              	    # transfer bootpack
  68 0064 8B350000 	    mov bootpack, %esi # from
  68      0000
  69 006a 8B3D0000 	    mov BOTPAK, %edi # to
  69      2800
  70 0070 B9000002 	    mov $512*1024/4, %ecx # 1024 sector
  70      00
  71 0075 E86C0000 	    call memcpy
  71      00
  72              	
  73              	    # transfer disc data
  74              	    # boot sector
  75 007a BE007C00 	    mov $0x7c00, %esi # from
  75      00
  76 007f 8B3D0000 	    mov DSKCAC, %edi # to
  76      1000
  77 0085 B9800000 	    mov $512/4, %ecx
  77      00
  78 008a E8570000 	    call memcpy
  78      00
  79              	
  80              	    # all remained
  81 008f 8B350082 	    mov DSKCAC0+512, %esi # from
  81      0000
  82 0095 8B3D0002 	    mov DSKCAC+512, %edi # to
  82      1000
  83 009b B9000000 	    mov $0, %ecx
  83      00
  84 00a0 8A0DF00F 	    movb (CYLS), %cl # ecx -> ch と cl
  84      0000
  85 00a6 69C90012 	    imul $512*18*2/4, %ecx # imul: signed multiply
  85      0000
  86 00ac 81E98000 	    sub $512/4, %ecx # subtract ipl size
  86      0000
  87 00b2 E82F0000 	    call memcpy
  87      00
  88              	
  89              	# asmhead done, start bootpack
  90 00b7 8B1D0000 	    mov BOTPAK, %ebx
  90      2800
  91 00bd 8B4B10   	    mov 16(%ebx), %ecx
GAS LISTING asmhead.s 			page 3


  92 00c0 83C103   	    add $3, %ecx
  93 00c3 C1E902   	    shr $2, %ecx # shr: shift right 2 == div 4
  94 00c6 740D     	    jz skip # nothing to transfer
  95 00c8 8B7314   	    mov 20(%ebx), %esi # from
  96 00cb 01DE     	    add %ebx, %esi
  97 00cd 8B7B0C   	    mov 12(%ebx), %edi
  98 00d0 E8110000 	    call memcpy
  98      00
  99              	skip:
 100 00d5 8B630C   	    mov 12(%ebx), %esp # stack initial value
 101              	    # GDTで設定したセグメントの1bへジャンプ
 102              	    # 1b には hrb 形式でのエントリーポイントがある
 103              	    # $2*8 -> RPL=0 (ring 0), TI=0 (GDT), index=0x10 (entry 2)
 104 00d8 EA1B0000 	    ljmp $2*8, $0x0000001b # Immediate form long jumps
 104      001000
 105              	
 106              	waitkbdout:
 107 00df E464     	    in $0x64, %al # in AL imm8: input from port
 108 00e1 2402     	    and $0x02, %al
 109 00e3 75FA     	    jnz waitkbdout
 110 00e5 C3       	    ret
 111              	
 112              	memcpy:
 113 00e6 8B06     	    mov (%esi), %eax
 114 00e8 83C604   	    add $4, %esi
 115 00eb 8907     	    mov %eax, (%edi)
 116 00ed 83C704   	    add $4, %edi
 117 00f0 83E901   	    sub $1, %ecx
 118 00f3 75F1     	    jnz memcpy
 119 00f5 C3       	    ret
 120              	
 121 00f6 662E0F1F 	    .align 16 # location counter を16の倍数まで進める (zero padding)
 121      84000000 
 121      0000
 122              	GDT0:
 123 0100 00000000 	    .skip 8 # intel needs null descriptor
 123      00000000 
 124              	    # 64 bit per entry (segment descriptor)
 125 0108 FFFF0000 	    .word 0xffff, 0x0000, 0x9200, 0x00cf # r/w able segment 32bit
 125      0092CF00 
 126 0110 FFFF0000 	    .word 0xffff, 0x0000, 0x9a28, 0x0047 # executable segment 32bit (bootpack)
 126      289A4700 
 127 0118 0000     	    .word 0
 128              	GDTR0:
 129 011a 1700     	    .word 8*3-1 # 1 引けってたしかに書いてある
 130 011c 00000000 	    .int GDT0 # .int == .long (32bit)
 131              	
 132              	    .align 16
 133              	bootpack:
GAS LISTING asmhead.s 			page 4


DEFINED SYMBOLS
           asmhead.s:3      *ABS*:0000000000280000 BOTPAK
           asmhead.s:4      *ABS*:0000000000100000 DSKCAC
           asmhead.s:5      *ABS*:0000000000008000 DSKCAC0
           asmhead.s:8      *ABS*:0000000000000ff0 CYLS
           asmhead.s:9      *ABS*:0000000000000ff1 LEDS
           asmhead.s:10     *ABS*:0000000000000ff2 VMODE
           asmhead.s:11     *ABS*:0000000000000ff4 SCRNX
           asmhead.s:12     *ABS*:0000000000000ff6 SCRNY
           asmhead.s:13     *ABS*:0000000000000ff8 VRAM
           asmhead.s:106    .text:00000000000000df waitkbdout
           asmhead.s:128    .text:000000000000011a GDTR0
           asmhead.s:59     .text:0000000000000056 pipelineflush
           asmhead.s:133    .text:0000000000000120 bootpack
           asmhead.s:112    .text:00000000000000e6 memcpy
           asmhead.s:99     .text:00000000000000d5 skip
           asmhead.s:122    .text:0000000000000100 GDT0

NO UNDEFINED SYMBOLS
